<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Take 5 / è°æ˜¯ç‰›å¤´ç‹</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #2c3e50; color: white; margin: 0; padding: 20px; }
        .container { max-width: 900px; margin: 0 auto; }
        
        /* è§†å›¾æ§åˆ¶ */
        .screen { display: none; }
        .screen.active { display: block; }

        /* ç™»å½•/å¤§å…æ ·å¼ */
        .auth-box {
            background: white; padding: 30px; border-radius: 10px; color: #333; 
            max-width: 400px; margin: 50px auto; box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        .auth-box h2 { margin-top: 0; color: #e67e22; text-align: center; }
        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 14px;}
        input[type="text"] {
            width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px; box-sizing: border-box; font-size: 16px;
        }
        
        .room-list { margin-top: 20px; border-top: 1px solid #eee; padding-top: 10px; max-height: 300px; overflow-y: auto;}
        .room-item {
            background: #f9f9f9; border: 1px solid #ddd; padding: 10px; margin-bottom: 8px; border-radius: 5px;
            display: flex; justify-content: space-between; align-items: center; cursor: pointer; transition: background 0.2s;
        }
        .room-item:hover { background: #eef2f3; }
        .room-info { font-size: 14px; }
        .room-status { font-size: 12px; padding: 2px 6px; border-radius: 4px; background: #95a5a6; color: white;}
        .room-status.waiting { background: #2ecc71; }
        .room-status.playing { background: #e74c3c; }

        /* æŒ‰é’® */
        button { padding: 10px 15px; font-size: 14px; cursor: pointer; border: none; color: white; border-radius: 5px; transition: opacity 0.2s; }
        button:hover { opacity: 0.9; }
        .btn-green { background: #27ae60; width: 100%; font-weight: bold; font-size: 16px; margin-bottom: 10px;}
        .btn-blue { background: #2980b9; }
        .btn-red { background: #c0392b; }
        .btn-orange { background: #e67e22; }
        .btn-small { padding: 5px 10px; font-size: 12px; }
        /* ç¡®è®¤å‡ºç‰ŒæŒ‰é’®æ ·å¼ */
        #btn-confirm-play {
            background: linear-gradient(45deg, #ff9800, #ffb74d);
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.25);
            animation: popIn 0.25s ease-out;
        }
        @keyframes popIn {
            from { transform: scale(0.85); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        /* æ¸¸æˆå†…æ ·å¼ */
        .game-header { display: flex; justify-content: space-between; align-items: center; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin-bottom: 20px; }
        .game-board { background-color: #34495e; padding: 20px; border-radius: 10px; margin-bottom: 20px; }
        .row { display: flex; margin-bottom: 10px; align-items: center; height: 75px; background: rgba(0,0,0,0.2); padding: 5px; border-radius: 5px; border: 2px solid transparent; }
        .row.selectable { border-color: #e74c3c; cursor: pointer; background: rgba(231, 76, 60, 0.2); }
        
        .card {
            width: 45px; height: 65px; background-color: #ecf0f1; color: #2c3e50;
            border-radius: 6px; display: flex; flex-direction: column; align-items: center; justify-content: space-between;
            font-weight: bold; margin-right: 8px; font-size: 16px; border: 2px solid #bdc3c7; padding: 2px; user-select: none;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            position: relative;
        }
        .card .bullheads { font-size: 10px; line-height: 10px; text-align: center; color: #c0392b; letter-spacing: -1px;}
        .card.score-1 { border-color: #bdc3c7; }
        .card.score-2 { border-color: #3498db; background-color: #d6eaf8; }
        .card.score-3 { border-color: #f1c40f; background-color: #fcf3cf; }
        .card.score-5 { border-color: #e67e22; background-color: #fad7a0; }
        .card.score-7 { border-color: #e74c3c; background-color: #f5b7b1; color: #c0392b; }

        .hand { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 20px; justify-content: center; min-height: 80px;}
        .hand .card { width: 55px; height: 80px; font-size: 20px; cursor: pointer;}
        .hand .card:hover { transform: translateY(-10px); background-color: #fff; z-index: 10;}
        .hand .card.selected { background-color: #2ecc71; color: white; border-color: #27ae60; transform: translateY(-30px); box-shadow: 0 10px 15px rgba(0,0,0,0.3); }
        .card.selected:hover { transform: translateY(-30px); }
        .hand .card.disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .hand.locked .card { opacity: 0.5; cursor: not-allowed; transform: none !important; }
        .hand.locked .card:hover { transform: none; }
        .hand.locked .card.selected { opacity: 1; border-color: #999; }
        .row.predicted { border-color: #f1c40f; box-shadow: 0 0 10px rgba(241,196,15,0.7); }
        .card.landing { animation: landIn 0.35s ease-out; }
        .card.fly-from-hand { transition: transform 0.4s linear; will-change: transform; }
        @keyframes landIn {
            from { transform: scale(0.6) translateY(-20px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        .player-list { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px; }
        .player-tag { background: #16a085; padding: 5px 10px; border-radius: 5px; font-size: 13px; min-width: 60px; text-align: center;}
        .player-tag.me { border: 2px solid #f1c40f; }
        .player-tag.ready { background: #27ae60; }
        .player-tag.owner::after { content: " ğŸ‘‘"; }

        /* æ¨¡æ€æ¡† */
        #stats-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; justify-content: center; align-items: center; z-index: 2000; }
        .stats-box { background: white; padding: 20px; border-radius: 10px; color: #333; width: 400px; max-width: 90%; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
    </style>
</head>
<body>

<!-- å¤§å…ç•Œé¢ -->
<div id="lobby-screen" class="screen active">
    <div class="auth-box">
        <h2>ğŸ® è°æ˜¯ç‰›å¤´ç‹ - å¤§å…</h2>
        
        <div class="input-group">
            <label>ä½ çš„æ˜µç§°</label>
            <input type="text" id="username-input" placeholder="è¯·è¾“å…¥æ˜µç§°" maxlength="10">
        </div>

        <div id="create-room-section">
            <div class="input-group">
                <label>åˆ›å»ºæ–°æˆ¿é—´</label>
                <div style="display: flex; gap: 5px;">
                    <input type="text" id="new-room-id" placeholder="ä¾‹å¦‚: 888">
                    <button class="btn-green" style="width: auto; margin:0;" onclick="createRoom()">åˆ›å»º</button>
                </div>
            </div>
        </div>

        <div class="room-list">
            <div style="font-weight: bold; margin-bottom: 10px;">æˆ¿é—´åˆ—è¡¨</div>
            <div id="room-container">
                <div style="text-align: center; color: #999;">æ­£åœ¨åŠ è½½æˆ¿é—´...</div>
            </div>
        </div>
    </div>
</div>

<!-- æ¸¸æˆç•Œé¢ -->
<div id="game-screen" class="screen">
    <div class="container">
        <div class="game-header">
            <div>
                <h3 style="margin:0; display: inline-block;">æˆ¿é—´: <span id="current-room-id">-</span></h3>
                <button class="btn-small btn-blue" onclick="copyInviteLink()" style="margin-left: 10px;">ğŸ”— å¤åˆ¶é‚€è¯·é“¾æ¥</button>
            </div>
            <div>
                <button class="btn-small btn-orange" onclick="showStats()">ğŸ“Š æˆ˜ç»©</button>
                <button class="btn-small btn-red" id="leave-btn" onclick="leaveRoom()">ğŸšª é€€å‡ºæˆ¿é—´</button>
                <button class="btn-small btn-red" id="delete-btn" onclick="deleteRoom()" style="display:none;">ğŸ—‘ï¸ è§£æ•£æˆ¿é—´</button>
            </div>
        </div>

        <div id="instruction" style="background: #d35400; padding: 10px; text-align: center; border-radius: 5px; margin-bottom: 15px; display: none; font-weight: bold;"></div>

        <div style="text-align: center; margin-bottom: 15px;">
            <button id="ready-btn" class="btn-green" style="width: 200px;" onclick="sendReady()">å‡†å¤‡ / Ready</button>
            <button id="restart-btn" class="btn-red" style="width: 200px; display:none;" onclick="sendRestart()">é‡æ–°å¼€å§‹</button>
            <button id="btn-confirm-play" class="btn-orange" style="width: 200px; display:none;" onclick="confirmPlay()">âœ… ç¡®è®¤å‡ºç‰Œ</button>
        </div>

        <div class="player-list" id="player-list"></div>

        <div class="game-board" id="board"></div>

        <h3>ä½ çš„æ‰‹ç‰Œ</h3>
        <div id="prediction-msg" style="text-align:center; min-height:18px; color:#f1c40f; margin-top:5px;"></div>
        <div class="hand" id="hand"></div>

        <div id="log" style="height: 100px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 10px; font-size: 12px; margin-top: 20px; font-family: monospace;"></div>
    </div>
</div>

<!-- æˆ˜ç»©æ¨¡æ€æ¡† -->
<div id="stats-modal" onclick="closeStats()">
    <div class="stats-box" onclick="event.stopPropagation()">
        <h3 style="text-align: center;">ğŸ† æˆ˜ç»©æ¦œ</h3>
        <table id="stats-table">
            <thead><tr><th>æ’å</th><th>ç©å®¶</th><th>å±€æ•°</th><th>æ€»åˆ†</th></tr></thead>
            <tbody id="stats-body"></tbody>
        </table>
        <div style="text-align: center; margin-top: 15px;"><button class="btn-blue" onclick="closeStats()">å…³é—­</button></div>
    </div>
</div>

<script>
    let ws;
    let lobbyWs;
    let myId = sessionStorage.getItem("take5_uid") || ""; 
    let myName = sessionStorage.getItem("take5_name") || "";
    let currentRoomId = "";
    let isOwner = false;
    let roomStats = [];
    let mySelectedCardValue = null;
    let currentGameState = null;
    let myConfirmPending = false;
    let lastPendingLogKey = "";
    let predictedRowIdx = null;
    let prevRowsSnapshot = null;
    let prevPlayersSnapshot = null;
    let lastSubmittedCardRect = null;

    window.onload = function() {
        sessionStorage.setItem("take5_uid", myId);
        if (myName) document.getElementById("username-input").value = myName;

        const urlParams = new URLSearchParams(window.location.search);
        const roomParam = urlParams.get('room');

        if (roomParam) {
            document.getElementById("new-room-id").value = roomParam;
            if (myName) {
                joinRoom(roomParam);
            } else {
                alert("è¯·å…ˆè¾“å…¥æ˜µç§°");
            }
        } else {
            connectLobby();
        }
    };

    function connectLobby() {
        if (lobbyWs) return;
        lobbyWs = new WebSocket("ws://" + window.location.host + "/lobby_ws");
        lobbyWs.onmessage = (evt) => {
            const msg = JSON.parse(evt.data);
            if (msg.type === "room_list") {
                renderRoomList(msg.payload);
            }
        };
    }

    function renderRoomList(rooms) {
        const container = document.getElementById("room-container");
        container.innerHTML = "";
        if (rooms.length === 0) {
            container.innerHTML = "<div style='text-align:center; padding:10px; color:#666;'>æš‚æ— æˆ¿é—´ï¼Œå¿«åˆ›å»ºä¸€ä¸ªå§ï¼</div>";
            return;
        }
        rooms.forEach(r => {
            const div = document.createElement("div");
            div.className = "room-item";
            div.innerHTML = `
                <div class="room-info">
                    <strong>æˆ¿é—´ ${r.id}</strong> <span style="color:#666">(${r.ownerName})</span>
                    <br>äººæ•°: ${r.playerCount}
                </div>
                <div class="room-status ${r.status}">${r.status === 'waiting' ? 'ç­‰å¾…ä¸­' : 'æ¸¸æˆä¸­'}</div>
            `;
            div.onclick = () => joinRoom(r.id);
            container.appendChild(div);
        });
    }

    function saveUserInfo() {
        const nameInput = document.getElementById("username-input");
        myName = nameInput.value.trim();
        if (!myName) { alert("è¯·è¾“å…¥æ˜µç§°"); return false; }
        sessionStorage.setItem("take5_name", myName);
        return true;
    }

    async function createRoom() {
        if (!saveUserInfo()) return;
        const roomId = document.getElementById("new-room-id").value.trim();
        if (!roomId) return alert("è¯·è¾“å…¥æˆ¿é—´å·");
        connectGameWs(roomId, "create_room");
    }

    async function joinRoom(roomId) {
        if (!saveUserInfo()) return;
        try {
            const res = await fetch(`/check_room?id=${roomId}`);
            const data = await res.json();
            if (!data.exists) {
                alert("æˆ¿é—´ä¸å­˜åœ¨ï¼");
                window.history.pushState({}, document.title, "/");
                connectLobby();
                return;
            }
            connectGameWs(roomId, "login");
        } catch (e) {
            alert("ç½‘ç»œé”™è¯¯");
        }
    }

    function connectGameWs(roomId, actionType) {
        if (ws) ws.close();
        ws = new WebSocket("ws://" + window.location.host + "/ws");
        
        ws.onopen = () => {
            ws.send(JSON.stringify({
                type: actionType,
                id: myId,
                payload: myName,
                roomId: roomId
            }));
        };

        ws.onmessage = (event) => {
            const msg = JSON.parse(event.data);
            if (msg.type === "identity") {
                myId = msg.payload.id;
                myName = msg.payload.name;
                sessionStorage.setItem("take5_uid", myId);
                sessionStorage.setItem("take5_name", myName);
                console.log("Identity confirmed:", myName, myId);
            } else if (msg.type === "error") {
                alert(msg.payload);
                ws.close();
                ws = null;
            } else if (msg.type === "state") {
                if (document.getElementById("lobby-screen").style.display !== "none") {
                    switchScreen("game");
                    const url = new URL(window.location);
                    url.searchParams.set('room', roomId);
                    window.history.pushState({}, '', url);
                    if (lobbyWs) { lobbyWs.close(); lobbyWs = null; }
                }
                handleStateUpdate(msg.payload);
            } else if (msg.type === "info") {
                log(msg.payload);
            } else if (msg.type === "stats") {
                roomStats = msg.payload || [];
                renderStats();
            } else if (msg.type === "room_closed") {
                alert("æˆ¿é—´å·²è§£æ•£");
                leaveRoom(true); 
            }
        };

        ws.onclose = () => {
            console.log("Game connection closed");
        };
    }

    function switchScreen(screen) {
        document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
        document.getElementById(screen + '-screen').classList.add('active');
    }

    function leaveRoom(passive = false) {
        if (!passive && ws) {
            ws.send(JSON.stringify({ type: "leave_room" }));
        }
        if (ws) ws.close();
        ws = null;
        currentRoomId = "";
        window.history.pushState({}, document.title, "/");
        switchScreen("lobby");
        connectLobby();
    }

    function deleteRoom() {
        if (confirm("ç¡®å®šè¦è§£æ•£æˆ¿é—´å—ï¼Ÿæ‰€æœ‰ç©å®¶å°†è¢«è¸¢å‡ºã€‚")) {
            ws.send(JSON.stringify({ type: "delete_room" }));
        }
    }

    function copyInviteLink() {
        const url = window.location.href;
        navigator.clipboard.writeText(url).then(() => {
            alert("é“¾æ¥å·²å¤åˆ¶: " + url);
        });
    }

    function handleStateUpdate(payload) {
        currentGameState = payload;
        const publicState = payload.publicState;
        const myHand = payload.myHand || [];
        const status = publicState.status;
        const me = publicState.players[myId] || {};
        if (payload.mySelectedCard !== undefined && payload.mySelectedCard !== null) {
            mySelectedCardValue = payload.mySelectedCard;
            myConfirmPending = true; // æ ‡è®°ä¸ºå·²ç¡®è®¤ï¼Œé”å®šæ‰‹ç‰Œ
        }

        const iHaveSelected = !!me.hasSelected;

        if (!iHaveSelected && status === "playing") {
             myConfirmPending = false;
             if (!myConfirmPending) {
                 // åªæœ‰åœ¨éç­‰å¾…ç¡®è®¤çŠ¶æ€ä¸‹æ‰æ¸…é™¤ï¼Œé¿å…é—ªçƒ
             }
        }
        if (status !== "playing" && status !== "choosing_row") {
            myConfirmPending = false;
            mySelectedCardValue = null;
        }

        const handValues = myHand.map(c => c.value);
        if (mySelectedCardValue !== null && !handValues.includes(mySelectedCardValue) && !myConfirmPending) {
            mySelectedCardValue = null;
        }

        currentRoomId = payload.roomId;
        document.getElementById("current-room-id").innerText = currentRoomId;

        isOwner = (publicState.ownerId === myId);
        document.getElementById("delete-btn").style.display = isOwner ? "inline-block" : "none";
        document.getElementById("restart-btn").style.display = (isOwner && status === "finished") ? "inline-block" : "none";

        renderPlayers(publicState.players, publicState.pendingPlayerId, publicState.ownerId);
        renderHand(myHand, status, iHaveSelected);
        updateConfirmButton(status, iHaveSelected);

        predictedRowIdx = predictRow(mySelectedCardValue, publicState.rows, status);
        renderPredictionMessage(predictedRowIdx);

        const landingMap = computeLanding(prevRowsSnapshot, publicState.rows);
        const landingAll = flattenLanding(landingMap);
        const playEvents = diffPlayerPlays(prevPlayersSnapshot, publicState.players, landingAll);
        
        const cardOwnerMap = {};
        playEvents.forEach(ev => { if(ev.cardValue) cardOwnerMap[ev.cardValue] = ev.id; });

        const animationTargets = renderBoard(publicState.rows, status, publicState.pendingPlayerId, predictedRowIdx, landingMap);

        if (animationTargets.length > 0) {
            processAnimations(animationTargets, cardOwnerMap);
        }

        playEvents.forEach(ev => {
            if (ev.cardValue !== null) {
                const rowIdx = findLandingRow(landingMap, ev.cardValue);
                const rowText = rowIdx !== null ? `ï¼Œè½åœ¨ç¬¬ ${rowIdx + 1} è¡Œ` : "";
                log(`${ev.name} å‡ºç‰Œ ${ev.cardValue}${rowText}`);
            }
        });
        prevRowsSnapshot = snapshotRows(publicState.rows);
        prevPlayersSnapshot = snapshotPlayers(publicState.players);

        if (publicState.pendingCard && publicState.pendingPlayerId) {
            const key = `${publicState.pendingPlayerId}-${publicState.pendingCard.value}`;
            if (key !== lastPendingLogKey) {
                lastPendingLogKey = key;
                const p = publicState.players[publicState.pendingPlayerId];
                const name = p ? p.name : "æœªçŸ¥ç©å®¶";
                log(`${name} çš„å‡ºç‰Œ ${publicState.pendingCard.value} ç­‰å¾…å¤„ç†`);
            }
        }
        
        updateInstructions(status, publicState);
    }

    function renderPlayers(players, pendingPid, ownerId) {
        const container = document.getElementById("player-list");
        container.innerHTML = "";
        Object.values(players).forEach(p => {
            const div = document.createElement("div");
            div.className = `player-tag ${p.id === myId ? 'me' : ''} ${p.ready ? 'ready' : ''} ${p.id === ownerId ? 'owner' : ''}`;
            div.dataset.uid = p.id; 
            div.innerText = `${p.name} (${p.score})`;
            container.appendChild(div);
        });
    }

    function renderBoard(rows, status, pendingPid, predictedRow, landingMap) {
        const board = document.getElementById("board");
        board.innerHTML = "";
        const isMyTurn = (status === "choosing_row" && pendingPid === myId);
        const animationTargets = [];
        
        rows.forEach((row, idx) => {
            const div = document.createElement("div");
            const classes = ["row"];
            if (isMyTurn) classes.push("selectable");
            if (predictedRow === idx) classes.push("predicted");
            div.className = classes.join(" ");
            div.dataset.rowIdx = idx;
            if (isMyTurn) div.onclick = () => { if(confirm("æ”¶èµ°æ­¤è¡Œ?")) ws.send(JSON.stringify({type:"choose_row", value: idx})); };
            
            const landingCards = landingMap.get(idx) || [];
            
            (row.cards || []).forEach(c => {
                const cardEl = createCard(c);
                cardEl.dataset.cardValue = c.value;
                const isNew = landingCards.some(lc => lc.value === c.value);
                if (isNew) {
                    cardEl.style.opacity = "0"; 
                    animationTargets.push({ element: cardEl, value: c.value });
                } else {
                    cardEl.style.opacity = "1";
                }
                div.appendChild(cardEl);
            });
            board.appendChild(div);
        });
        return animationTargets;
    }

    function processAnimations(targets, cardOwnerMap) {
        document.body.offsetHeight; 
        targets.forEach(target => {
            const cardEl = target.element;
            const value = target.value;
            const ownerId = cardOwnerMap[value];
            const endRect = cardEl.getBoundingClientRect();
            let startRect = null;

            if (ownerId === myId) {
                if (lastSubmittedCardRect) startRect = lastSubmittedCardRect;
            } else if (ownerId) {
                const playerEl = document.querySelector(`.player-tag[data-uid="${ownerId}"]`);
                if (playerEl) startRect = playerEl.getBoundingClientRect();
            }

            if (!startRect) {
                cardEl.style.opacity = "1";
                return;
            }

            const ghost = cardEl.cloneNode(true);
            ghost.style.transition = "none"; 
            ghost.style.opacity = "1";
            ghost.style.position = "fixed";
            ghost.style.margin = "0";
            ghost.style.zIndex = "3000";
            ghost.style.pointerEvents = "none";
            
            const startCenterX = startRect.left + startRect.width / 2;
            const startCenterY = startRect.top + startRect.height / 2;
            const cardWidth = endRect.width;
            const cardHeight = endRect.height;
            const initialLeft = startCenterX - cardWidth / 2;
            const initialTop = startCenterY - cardHeight / 2;

            ghost.style.left = `${initialLeft}px`;
            ghost.style.top = `${initialTop}px`;
            ghost.style.width = `${cardWidth}px`;
            ghost.style.height = `${cardHeight}px`;
            ghost.style.transform = "translate(0, 0) scale(0.5)";

            document.body.appendChild(ghost);

            void ghost.offsetWidth;
            requestAnimationFrame(() => {
                ghost.style.transition = "transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1)";
                requestAnimationFrame(() => {
                    const deltaX = endRect.left - initialLeft;
                    const deltaY = endRect.top - initialTop;
                    ghost.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(1)`;
                });
            });

            setTimeout(() => {
                ghost.remove();
                cardEl.style.opacity = "1";
                cardEl.classList.add("landing");
                setTimeout(() => cardEl.classList.remove("landing"), 500);
            }, 650);
        });
        lastSubmittedCardRect = null;
    }

    function renderHand(hand, status, iHaveSelected) {
        const container = document.getElementById("hand");
        container.innerHTML = "";
        const isLocked = myConfirmPending || iHaveSelected || status !== "playing";
        container.className = `hand ${isLocked ? 'locked' : ''}`;

        hand.forEach(c => {
            const el = createCard(c);
            if (mySelectedCardValue === c.value) {
                el.classList.add("selected");
            }
            el.onclick = (e) => {
                if (isLocked) return;
                if (mySelectedCardValue === c.value) {
                    mySelectedCardValue = null;
                } else {
                    mySelectedCardValue = c.value;
                }
                predictedRowIdx = predictRow(mySelectedCardValue, currentGameState ? currentGameState.publicState.rows : [], status);
                renderPredictionMessage(predictedRowIdx);
                if (currentGameState) {
                    renderBoard(currentGameState.publicState.rows, status, currentGameState.publicState.pendingPlayerId, predictedRowIdx, new Map());
                }
                updateConfirmButton(status, iHaveSelected);
                renderHand(hand, status, iHaveSelected);
            };
            container.appendChild(el);
        });
    }

    function confirmPlay() {
        if (mySelectedCardValue === null) return;
        const selEl = document.querySelector("#hand .card.selected");
        if (selEl) {
            const rect = selEl.getBoundingClientRect();
            lastSubmittedCardRect = {
                left: rect.left, top: rect.top, width: rect.width, height: rect.height
            };
        }
        ws.send(JSON.stringify({type: "play_card", value: mySelectedCardValue}));
        myConfirmPending = true;
        const handEl = document.getElementById("hand");
        if (handEl) handEl.classList.add("locked");
        updateConfirmButton("playing", true);
        log(`ä½ å·²æäº¤å‡ºç‰Œ ${mySelectedCardValue}ï¼Œç­‰å¾…å…¶ä»–ç©å®¶ç¡®è®¤...`);
    }

    function createCard(c) {
        const div = document.createElement("div");
        let scoreClass = "score-1";
        if (c.score === 2) scoreClass = "score-2";
        if (c.score === 3) scoreClass = "score-3";
        if (c.score === 5) scoreClass = "score-5";
        if (c.score === 7) scoreClass = "score-7";
        div.className = `card ${scoreClass}`;
        div.innerHTML = `<span style="margin-top:2px">${c.value}</span><div class="bullheads">${'ğŸ®'.repeat(c.score > 3 ? 3 : c.score)}</div>`;
        return div;
    }

    function updateConfirmButton(status, iHaveSelected) {
        const btn = document.getElementById("btn-confirm-play");
        if (!btn) return;
        const shouldShow = status === "playing" && !iHaveSelected && !myConfirmPending && mySelectedCardValue !== null;
        btn.style.display = shouldShow ? "inline-block" : "none";
    }

    function updateInstructions(status, publicState) {
        const instruction = document.getElementById("instruction");
        const readyBtn = document.getElementById("ready-btn");
        if (status === "waiting") {
            readyBtn.style.display = "inline-block";
            const meReady = publicState.players[myId];
            readyBtn.innerText = (meReady && meReady.ready) ? "ç­‰å¾…å…¶ä»–äºº..." : "å‡†å¤‡ / Ready";
            readyBtn.disabled = (meReady && meReady.ready);
            instruction.style.display = "none";
        } else {
            readyBtn.style.display = "none";
            if (status === "choosing_row") {
                instruction.style.display = "block";
                if (publicState.pendingPlayerId === myId) {
                    instruction.style.background = "#e74c3c";
                    instruction.innerHTML = `âš ï¸ è¯·é€‰æ‹©ä¸€è¡Œæ”¶èµ°ï¼`;
                } else {
                    instruction.style.background = "#d35400";
                    instruction.innerText = `ç­‰å¾…æŸäººé€‰è¡Œ...`;
                }
            } else {
                instruction.style.display = "none";
            }
        }
    }

    function predictRow(value, rows, status) {
        if (status !== "playing" || value === null || !rows) return null;
        let bestIdx = -1;
        let diff = 1e9;
        rows.forEach((row, idx) => {
            if (!row.cards || row.cards.length === 0) return;
            const last = row.cards[row.cards.length - 1].value;
            if (value > last && value - last < diff) {
                diff = value - last;
                bestIdx = idx;
            }
        });
        return bestIdx === -1 ? -1 : bestIdx;
    }

    function renderPredictionMessage(idx) {
        const el = document.getElementById("prediction-msg");
        if (!el) return;
        if (idx === null) el.innerText = "";
        else if (idx === -1) el.innerText = "è¿™å¼ ç‰Œå¯èƒ½è§¦å‘æ”¶è¡Œï¼Œè¯·è°¨æ…é€‰æ‹©ã€‚";
        else el.innerText = `é¢„è®¡å°†æ”¾å…¥ç¬¬ ${idx + 1} è¡Œ`;
    }
    function snapshotRows(rows) { return rows ? rows.map(r => r.cards ? r.cards.map(c => c.value) : []) : null; }
    function computeLanding(prev, current) {
        const res = new Map();
        if (!prev) return res;
        current.forEach((row, idx) => {
            const prevVals = prev[idx] || [];
            const added = (row.cards || []).filter(c => !prevVals.includes(c.value));
            if (added.length > 0) res.set(idx, added);
        });
        return res;
    }
    function flattenLanding(landingMap) {
        const arr = [];
        landingMap.forEach(cards => cards.forEach(c => arr.push(c)));
        return arr;
    }
    function snapshotPlayers(players) {
        if (!players) return null;
        const res = {};
        Object.values(players).forEach(p => { res[p.id] = { handSize: p.handSize ?? 0 }; });
        return res;
    }
    function diffPlayerPlays(prevSnap, currPlayers, landingCards) {
        const events = [];
        landingCards.forEach(card => {
            if (card.ownerId && currPlayers[card.ownerId]) {
                const p = currPlayers[card.ownerId];
                events.push({ id: p.id, name: p.name, cardValue: card.value });
            }
        });
        return events;
    }
    function findLandingRow(landingMap, val) {
        let hit = null;
        landingMap.forEach((cards, idx) => { if (cards.some(c => c.value === val)) hit = idx; });
        return hit;
    }
    function sendReady() { ws.send(JSON.stringify({type: "ready"})); }
    function sendRestart() { ws.send(JSON.stringify({type: "restart"})); }
    function showStats() { document.getElementById("stats-modal").style.display = "flex"; renderStats(); }
    function closeStats() { document.getElementById("stats-modal").style.display = "none"; }
    function renderStats() {
        const tbody = document.getElementById("stats-body");
        tbody.innerHTML = "";
        roomStats.forEach((s, i) => {
            tbody.innerHTML += `<tr><td>${i+1}</td><td>${s.name}</td><td>${s.totalGames}</td><td>${s.totalScore}</td></tr>`;
        });
    }
    function log(msg) {
        const d = document.getElementById("log");
        d.innerHTML = `<div>${msg}</div>` + d.innerHTML;
    }
</script>
</body>
</html>